Title: Основы WebGL2
Description: Your first WebGL2 lesson starting with the fundamentals
TOC: Основы

Прежде всего, эти статьи посвящены WebGL2. Если вас интересует WebGL 1.0. [пожалуйста, перейдите сюда](https://webglfundamentals.org). Обратите внимание, что WebGL2 [почти на 100% обратно совместим с WebGL 1](webgl1-to-webgl2.html). Учитывая это, как только вы включите WebGL2, вы можете использовать его так, как его и было задуманно использовать. Эти уроки следуют по этому пути.

WebGL часто воспринимается как 3D API. Люди думают: "Я использую WebGL, и *магия!* я получу крутое 3d". На самом деле WebGL — это просто движок растеризации. Он рисует [точки, линии и треугольники](webgl-points-lines-triangles.html) на основе предоставляемого вами кода. Чтобы заставить WebGL делать что-либо еще, вы должны предоставить код для использования точек, линий и треугольников для выполнения *вашей* задачи.

WebGL работает на графическом процессоре (GPU) вашего компьютера. Поэтому вам нужно предоставить код, который будет работать на этом GPU. Вы предоставляете его в виде пары функций. Эти две функции называются *вершинный шейдер*(vertex shader) и *фрагментный шейдер*(fragment shader), и каждая из них написана на очень строго типизированном языке типа C/C++ под названием [GLSL](webgl-shaders-and-glsl.html). (GL Shader Language). В паре они называются *шейдерной программой*.

Работа вершинного шейдера заключается в *вычислении положения вершин*. На основе этих позиций, которые возвращает функция, WebGL может растеризовать различные виды примитивов, включая [точки, линии или треугольники](webgl-points-lines-triangles.html). При растеризации этих примитивов вызывается вторая пользовательская функция, называемая фрагментным шейдером.
Работа фрагментного шейдера заключается в *вычислении цвета для каждого пикселя* рисуемого в текущий момент примитива.

Почти весь WebGL API посвящен [установке состояния](resources/webgl-state-diagram.html) для выполнения этой пары функций. Для каждого объекта, который вы хотите нарисовать, вы устанавливаете кучу состояний, а затем выполняете пару функций, вызывая `gl.drawArrays` или `gl.drawElements`, которые выполняют ваши шейдеры на GPU.

Любые данные, к которым вы хотите, чтобы эти функции имели доступ, должны быть предоставлены GPU. Существует 4 способа как шейдер может получать данные.

1. Атрибуты, буферы и массивы вершин (**Attributes**, **Buffers**, and **Vertex Arrays**)

   Буферы (**Buffers**) — это массивы двоичных данных, которые вы загружаете в GPU. Обычно буферы содержат такие вещи, как позиции, нормали, координаты текстур, цвета вершин и т.д., хотя вы можете поместить в них все, что захотите.

   Атрибуты (**Attributes**) используются для указания того, *как* извлекать данные из буферов и предоставлять их вершинному шейдеру. Например, вы можете поместить позиции в буфер в виде трех 32-разрядных плавающих чисел (32-bit floats) на позицию. Вы указываете определенному атрибуту, из какого буфера извлекать позиции, какого типа извлекать данные (трехкомпонентные 32-битные числа с плавающей запятой), с какого смещения в буфере начинаются позиции, и сколько байт нужно получить от одной позиции до другой.

   Буферы *не имеют произвольного доступа*. Вместо этого вершинный шейдер выполняется определенное количество раз. При каждом выполнении следующее значение из каждого указанного буфера извлекается и присваивается атрибуту (по известному смещению и типу (=размеру в буфере) данных).

   Состояние атрибутов, какие буферы использовать для каждого из них и как извлекать данные из этих буферов собираются в объект массива вершин (**VAO - Vertex Array Object**).

2. Униформы (**Uniforms**)

   Униформы – это глобальные переменные, которые вы устанавливаете перед выполнением программы шейдера.

3. Текстуры (**Textures**)

   Текстуры – это массивы данных, к которым вы можете *произвольно обращаться* в своей шейдерной программе. Наиболее чаще всего в текстуру помещают данные изображения, но текстуры – это всего лишь данные, и они с легкостью могут содержать не только цвета.

4. Переменные/Вариации (**Varyings**)

  Переменные – это способ передачи данных от вершинного шейдера фрагментному шейдеру. В зависимости от того, что отображается (точки, линии или треугольники), значения, установленные для переменной вершинным шейдером, будут интерполироваться при выполнении фрагментного шейдера.  

## WebGL Hello World

WebGL заботится только о двух вещах: координаты пространства отсечки (clip space) и цвета. Ваша работа как программиста, использующего WebGL, заключается в том, чтобы обеспечить WebGL этими двумя вещами. Для этого вы предоставляете свои два "шейдера". Вершинный шейдер, который предоставляет координаты пространства отсечки, и фрагментный шейдер, который предоставляет цвет.

Координаты пространства отсечки всегда изменяются от -1 до +1, *независимо* от размера холста. Вот простой WebGL пример, который демонстрирует WebGL в его самой простой форме.

Начнем с вершинного шейдера:

    #version 300 es

    // Атрибут явлется входом (in)*put* вертексного шейдера.
    // Он получает данные из буфера.
    in vec4 a_position;

    // все шейдеры содержат функцию main()
    void main() {

      // gl_Position – это специальная переменная, 
      // за инициализацию которой отвечает вершинный шейдер.
      gl_Position = a_position;
    }

При выполнении, если бы все это было написано на JavaScript вместо GLSL,
то можно представить, что программа будет использоваться следующим образом:

    // *** ПСЕВОДОКОД!!! ***

    var positionBuffer = [
      0, 0, 0, 0,
      0, 0.5, 0, 0,
      0.7, 0, 0, 0,
    ];
    var attributes = {};
    var gl_Position;

    drawArrays(..., offset, count) {
      var stride = 4;
      var size = 4;
      for (var i = 0; i < count; ++i) {
         // скопироать следующие 4 значения из positionBuffer в атрибут a_position
         const start = offset + i * stride;
         attributes.a_position = positionBuffer.slice(start, start + size);
         runVertexShader();
         ...
         doSomethingWith_gl_Position();
    }

В действительности всё не так просто, потому что буфер `positionBuffer` необходимо будет преобразовать в двоичные данные (см. ниже) и поэтому фактические вычисления для получения данных из буфера будет немного отличаться, но, надеюсь, это даст вам представление о том, как будет выполняться вершинный шейдер.

Далее нам потребуется фрагметный шейдер:

    #version 300 es

    // фрагментный шейдеры не имеют точности по умолчанию, so we need
    // поэтому нам необходимо выборать одну из них. highp – хороший дефолтный выбор, означает высокую точность (high precision)
    precision highp float;

    // мы должны объявить выход фрагментного шейдера
    out vec4 outColor;

    void main() {
      // Просто установим цвет числовым значением на красно-пурпурный
      outColor = vec4(1, 0, 0.5, 1);
    }

Выше мы объявили `outColor` в качестве выхода нашего фрагментного шейдера. Мы устанавливаем для `outColor` значение `1, 0, 0.5, 1`.
что означает `1` для красного, `0` для зеленого, `0,5` для синего и `1` для альфа-канала (прозрачности). Цвета в WebGL изменяются в диапазоне от 0 до 1 (нормализованы).

Теперь, когда мы написали две шейдерные функции, давайте приступим к работе с WebGL.

Сначала нам понадобится HTML-элемент холста:

     <canvas id="c"></canvas>

Затем в JavaScript мы можем посмотреть это:

     var canvas = document.querySelector("#c");

Теперь мы можем создать так называемый *контекст рендеринга* – WebGL2RenderingContext:

     var gl = canvas.getContext("webgl2");
     if (!gl) {
        // никакого тебе webgl2!
        ...

Теперь нам нужно скомпилировать эти шейдеры, чтобы скормить их GPU, поэтому сначала нам нужно преобразовать их в строки (*strings*).
Вы можете создавать строки GLSL любым способом, которым вы обычно создаете строки в JavaScript. Например, путем конкатенации; используя AJAX для их загрузки; помещая их в теги сценариев, не относящихся к JavaScript, или, как в данном случае, помещая в многострочные строки шаблона.

    var vertexShaderSource = `#version 300 es

    // an attribute is an input (in) to a vertex shader.
    // It will receive data from a buffer
    in vec4 a_position;

    // all shaders have a main function
    void main() {

      // gl_Position is a special variable a vertex shader
      // is responsible for setting
      gl_Position = a_position;
    }
    `;

    var fragmentShaderSource = `#version 300 es

    // fragment shaders don't have a default precision so we need
    // to pick one. highp is a good default. It means "high precision"
    precision highp float;

    // we need to declare an output for the fragment shader
    out vec4 outColor;

    void main() {
      // Just set the output to a constant reddish-purple
      outColor = vec4(1, 0, 0.5, 1);
    }
    `;

На самом деле, большинство 3D-движков генерируют GLSL-шейдеры на лету, используя различные типы шаблонов, конкатенацию и т.д. Однако для примеров на этом сайте ни один из них не является настолько сложным, чтобы требовалось генерировать GLSL во время выполнения.

> ПРИМЕЧАНИЕ: `#version 300 es` **ДОЛЖНО БЫТЬ САМОЙ ПЕРВОЙ СТРОКОЙ В КОДЕ ВАШЕГО ШЕЙДЕРА**. Недопустимы комментарии или пустые строки до нее! `#version 300 es` указывает WebGL2, что вы хотите использовать версию шейдерного языкы WebGL2, который называется **GLSL ES 3.00**. Если вы не поместите эту директиву в первую строку, то шейдер по умолчанию будет использовать язык WebGL 1.0 GLSL ES 1.00, который имеет много отличий и гораздо меньше возможностей.

Далее нам понадобится функция, которая создается шейдер, загружает GLSL исходник и компилирует шейдер.
Обратите внимание, что я опустил комментарии, потому что из названий функций должно быть ясно.
что происходит:

    function createShader(gl, type, source) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (success) {
        return shader;
      }

      console.log(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
    }

Теперь мы можем вызвать эту функцию для создания двух шейдеров:

    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

Нам нужно *прилинковать* эти два шейдера к *программе* с помощью функции:

    function createProgram(gl, vertexShader, fragmentShader) {
      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      var success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (success) {
        return program;
      }

      console.log(gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
    }

И вызвать ее, чтобы непосредственно создать программу:

    var program = createProgram(gl, vertexShader, fragmentShader);

Теперь, когда мы создали GLSL-программу на GPU, нам нужно предоставить ей данные.
Большая часть WebGL API посвящена установке/настройке состояния для предоставления данных нашим GLSL-программам.
В данном случае единственным входом для нашей GLSL-программы является атрибут `a_position`. Первое, что мы должны сделать, это найти местоположение атрибута для программы,
которую мы только что создали:

    var positionAttributeLocation = gl.getAttribLocation(program, "a_position");

Поиск местоположений атрибутов (и uniform местоположений) — это то, что вы должны делать *во время инициализации*, а не в цикле рендеринга.

Атрибуты получают свои данные из буферов, поэтому нам нужно создать буфер:

    var positionBuffer = gl.createBuffer();

WebGL позволяет нам манипулировать многими ресурсами WebGL в глобальных точках привязки (*bind points*). Точки привязки можно рассматривать как внутренние глобальные переменные WebGL. Сначала вы привязываете ресурс к точке привязки. Затем все остальные функции обращаются к ресурсу через эту точку привязки. Итак, давайте привяжем буфер позиции.

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

Теперь мы можем поместить данные в этот буфер, обратившись к нему через точку привязки:

    // три 2d точки
    var positions = [
      0, 0,
      0, 0.5,
      0.7, 0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

Здесь происходит много всего. Во-первых, у нас есть `positions`, который представляет собой массив JavaScript. WebGL, с другой стороны, нуждается в сильно типизированных данных, поэтому часть `new Float32Array(positions)` создает новый массив 32-битных чисел с плавающей точкой и копирует в него значения из `positions`. Затем `gl.bufferData` копирует эти данные в `positionBuffer` на GPU. Он использует буфер позиции, потому что мы привязали его к точке привязки `ARRAY_BUFFER` выше.

Последний аргумент, `gl.STATIC_DRAW`, является подсказкой для WebGL о том, как мы будем использовать данные. WebGL может попытаться использовать эту подсказку для оптимизации некоторых вещей. `gl.STATIC_DRAW` сообщает WebGL, что мы вряд ли будем часто менять эти данные.

Теперь, когда мы поместили данные в буфер, нам нужно указать атрибуту, как получить данные из него. Сначала нам нужно создать коллекцию состояния атрибута под названием **Vertex Array Object** (VBO).

    var vao = gl.createVertexArray();

И нам нужно сделать этот массив текущим массивом вершин, таким образом все наши настройки атрибутов будут применяться к этому набору состояний атрибутов:

    gl.bindVertexArray(vao);

Теперь мы окончательно настроим атрибуты в массиве вершин. Прежде всего, нам нужно включить атрибут. Это говорит WebGL, что мы хотим получить данные из буфера. Если мы не включим атрибут, то атрибут будет иметь постоянное значение.

    gl.enableVertexAttribArray(positionAttributeLocation);

Затем нам нужно указать, как извлечь данные:

    var size = 2;          // 2 компонента за итерацию
    var type = gl.FLOAT;   // данные типа 32-bit float
    var normalize = false; // отключаем нормализацию данных
    var stride = 0;        // 0 = перемещается вперед на size * sizeof(type) за каждую итерацию, чтобы добраться к следующей позиции
    var offset = 0;        // читаем с начала буфера
    gl.vertexAttribPointer(
        positionAttributeLocation, size, type, normalize, stride, offset)


Скрытая часть `gl.vertexAttribPointer` заключается в том, что он привязывает текущий `ARRAY_BUFFER` к атрибуту. Другими словами, теперь этот атрибут привязан к
`positionBuffer`. Это означает, что мы можем привязать что-нибудь другое к точке привязки `ARRAY_BUFFER`. Атрибут будет продолжать использовать `positionBuffer`.

Обратите внимание, что с точки зрения нашего GLSL вершинного шейдера атрибут `a_position` является `vec4`.

    in vec4 a_position;

`vec4` – это значение, состоящее из 4-х чисел с плавающей точкой. В JavaScript вы можете представить это примерно так `a_position = {x: 0, y: 0, z: 0, w: 0}`. Выше мы установили `size = 2`. Атрибуты по умолчанию равны `0, 0, 0, 0, 1`, поэтому этот атрибут получит свои первые два значения (x и y) из нашего буфера. Значения z и w будут по умолчанию равны 0 и 1 соответственно.

Перед рисованием мы должны изменить размер холста, чтобы он соответствовал размеру экрана. Холсты, как и изображения, имеют два размера.
Фактическое количество пикселей в них и отдельно – размер, в котором они отображаются. CSS определяет размер отображения холста. **Вы всегда должны задавать нужный размер холста с помощью CSS**, так как он намного более гибким, чем любой другой метод.

Чтобы количество пикселей в холсте соответствовало размеру отображаемого изображения
[я использую вспомогательную функцию, о которой вы можете прочитать здесь](webgl-resizing-the-canvas.html).

Почти во всех этих примерах размер холста составляет 400x300 пикселей, если пример запускается в собственном окне.
но растягивается, чтобы заполнить доступное пространство, если он находится внутри iframe, как на этой странице.
Позволяя CSS определять размер, а затем подгонять его под него, мы легко справляемся с обоими этими случаями.

    webglUtils.resizeCanvasToDisplaySize(gl.canvas);

TODO: перевод след. абзаца требует перепроверки

Нам нужно указать WebGL, как конвертировать из значений пространства отсечки (Clip Space), к которым мы установим `gl_Position`, обратно в пиксели, часто называемые экранным пространстовм (Screen Space).

(**Original paragraph**)
We need to tell WebGL how to convert from the clip space
values we'll be setting `gl_Position` to back into pixels, often called screen space.

Чтобы это осуществить, мы вызываем функцию `gl.viewport` и передаем ей в качестве аргументов текущие габариты холста.

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

Это сообщает WebGL, что диапазон `[-1;+1]` пространства отсечки  отображается диапазон [0; `gl.canvas.width`] для x и [0; `gl.canvas.height`].
для y.

Мы очищаем холст. Значения `0, 0, 0, 0` — это красный (red), зеленый (green), синий (blue), альфа канал (alpha) соотвественно, таким образом мы делаем холст прозрачным.

    // Очищаем холст
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

Далее нам нужно указать WebGL, какую шейдерную программу необходимо выполнить.

    // Указать ему использовать наши программы (пару шейдеров)
    gl.useProgram(program);

Затем нам нужно сказать ему, какой набор буферов использовать и как извлекать данные из этих буферов, чтобы предоставить их атрибутам:

    // Связать нужный нам набор атрибутов/буферов.
    gl.bindVertexArray(vao);

После всего этого мы можем попросить WebGL выполнить нашу GLSL-программу.

    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 3;
    gl.drawArrays(primitiveType, offset, count);

Поскольку счетчик равен `3`, это приведет к выполнению нашего вершинного шейдера 3 раза. В первый раз `a_position.x` и `a_position.y` в атрибуте вершинного шейдера будут установлены в первые 2 значения из positionBuffer. Во второй раз `a_position.xy` будут установлены на два вторых значения. В последний раз он будут
будет установлены на последние 2 значения.

Поскольку мы установили `primitiveType` в `gl.TRIANGLES`, каждый раз, когда наш вершинный шейдер запускается 3 раза, WebGL будет рисовать треугольник на основе трех значений, которым мы задали `gl_Position`. Неважно, какого размера наш холст, эти значения находятся в координатах пространства отсечки, которые простираются от -1 до 1 в каждом направлении.

Поскольку наш вершинный шейдер просто копирует значения positionBuffer в `gl_Position`, треугольник будет нарисован в координатах пространства отсечки:

      0, 0,
      0, 0.5,
      0.7, 0,

При преобразовании из пространства отсечки в экранное пространство с холстом 400x300 пикселей, мы получим что-то вроде этого:

     clip space      screen space
       0, 0       ->   200, 150
       0, 0.5     ->   200, 225
     0.7, 0       ->   340, 150

Теперь WebGL будет отрисовывать этот треугольник. Для каждого пикселя, который он собирается отрисовать, WebGL будет вызывать наш фрагментный шейдер, который просто устанавливает `outColor` в значение `1, 0, 0.5, 1`. Поскольку холст является 8-битным
на канал, это означает, что WebGL собирается записать значения `[255, 0, 127, 255]` в холст.

Вот "живая" версия:

{{{example url="../webgl-fundamentals.html" }}}

В приведенном выше примере видно, что наш вершинный шейдер не делает ничего, кроме прямой передачи данных о положении. Поскольку данные о положении уже находятся в пространстве отсечки, нам не нужно ничего делать. *Если вы хотите 3D, вы должны сами предоставить шейдеры, которые преобразуют 3D позиции в пространство отсечки, поскольку WebGL - это только API растеризации*.

Вы можете задаться вопросом, почему треугольник начинается в середине и идет к правому верхнему углу. Пространство клипа в `x` идет от -1 до +1. Это означает, что начало отсчета (0,0) находится в центре, а положительные значения будут справа от него (и вверх для `y`).

Что касается того, почему он находится сверху, то в пространстве отсечки -1 находится внизу, а +1 - вверху. Это означает, что 0 находится в центре, поэтому положительные числа будут лежать выше центра.

Для 2D вещей вы, вероятно, предпочтете работать в пикселях, а не в пространстве отсечки, поэтому давайте изменим шейдер так, чтобы мы могли задавать позицию в пикселях и чтобы он сам преобразовывал её в пространство отсечки. Вот новый вершинный шейдер:

    -  in vec4 a_position;
    +  in vec2 a_position;

    +  uniform vec2 u_resolution;

      void main() {
    +    // преобразовать позицию из пикселей в [0;1]
    +    vec2 zeroToOne = a_position / u_resolution;
    +
    +    // преобразовать из 0->1 в 0->2
    +    vec2 zeroToTwo = zeroToOne * 2.0;
    +
    +    // преобразовать из 0->2 в -1->+1 (clip space)
    +    vec2 clipSpace = zeroToTwo - 1.0;
    +
    *    gl_Position = vec4(clipSpace, 0, 1);
      }

Некоторые вещи, которые следует отметить в связи с изменениями. Мы заменили тип `a_position` на `vec2`, поскольку в любом случае мы используем только `x` и `y`. Тип `vec2` похож на `vec4`, но имеет только `x` и `y`.

Далее мы добавили `uniform` с именем `u_resolution`. Чтобы установить его, нам нужно найти его местоположение.

    var resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");

Остальное должно быть понятно из комментариев. Установив `u_resolution` на разрешение нашего холста, шейдер теперь будет принимать позиции, которые мы поместили в `positionBuffer`, предоставленные в пиксельных координатах и преобразовывать их в пространство отсечки.

Теперь мы можем изменить значения позиции из пространства отсечки в пиксели. На этот раз мы нарисуем прямоугольник из двух треугольников, по 3 точки в каждом.

    var positions = [
    *  10, 20,
    *  80, 20,
    *  10, 30,
    *  10, 30,
    *  80, 20,
    *  80, 30,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

И после того, как мы установили, какую программу использовать, мы можем установить значение для созданной нами униформы. Функция `gl.useProgram` подобна рассмотренной выше `gl.bindBuffer` в том, что она устанавливает текущую программу. После этого все функции `gl.uniformXXX` устанавливают униформы на текущую программу.

And after we set which program to use we can set the value for the uniform we created. `gl.useProgram` is like `gl.bindBuffer` above in that it sets the current program. After that all the `gl.uniformXXX` functions set uniforms on the current program.

    gl.useProgram(program);

    // Передаем разрешение холста, таким образом м можем переходить
    // от пикселей к пространству отсечки в шейдере
    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

И разумеется, чтобы нарисовать 2 треугольника, нам нужно заставить WebGL вызвать наш вершинный шейдер 6 раз, поэтому нам необходимо изменить значение `count` на `6`.

    // рисуем прямоугольник
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    *var count = 6;
    gl.drawArrays(primitiveType, offset, count);

А вот и он:

ПРИМЕЧАНИЕ: Этот и все последующие примеры используют скрипт [`webgl-utils.js`](/webgl/resources/webgl-utils.js), который содержит функции для компиляции и линковки шейдеров. Нет никакой причины перегружать примеры этим [шаблонным](webgl-boilerplate.html) кодом.

{{{example url="../webgl-2d-rectangle.html" }}}

И снова вы можете заметить, что прямоугольник находится у нижнего края области.
WebGL полагает, что положительное напраление оси Y указывает вверх, а отричательное — вниз. В пространстве отсечки левый нижний угол имеет координаты (-1; -1). Мы не изменяли знаки, поэтому с нашей текущей математикой 0(нуля), начало отсчёта устанавливается в левый нижний угол. Чтобы получить более традиционное начало от левого верхнего угла, используемое в API 2d графики, мы можем просто перевернуть y-координату пространства отсечки:

    *   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

И теперь наш прямоугльник там, где мы и ожидали его увидеть.

{{{example url="../webgl-2d-rectangle-top-left.html" }}}

Давайте сделаем код, который описывет прямоугльник, функцией, таким образом мы сможем вызывать его для прямоугльников разного размера. А пока мы здесь, то также сделаем и цвет настраиваемым значением.

Сначала мы сделаем так, чтобы фрагментный шейдер принимал на входе uniform переменную цвета.

    #version 300 es

    precision highp float;

    +  uniform vec4 u_color;

    out vec4 outColor;

    void main() {
    -  outColor = vec4(1, 0, 0.5, 1);
    *  outColor = u_color;
    }

А вот и наш новый код, который рисует 50 прямоугольников в случайных местах и случайного цвета.

      var colorLocation = gl.getUniformLocation(program, "u_color");
      ...

      // Рисуем 50 разных прямоугольников разного цвета
      for (var ii = 0; ii < 50; ++ii) {
        // Устанавливаем случайный прямоугльник
        setRectangle(
            gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

        // Устанавливаем случайны цвет.
        gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

        // Рисуем прямоугольник.
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 6;
        gl.drawArrays(primitiveType, offset, count);
      }
    }

    // Returns a random integer from 0 to range - 1.
    function randomInt(range) {
      return Math.floor(Math.random() * range);
    }

    // Заполняем буфер значенями, определяющими прямоугольник.

    function setRectangle(gl, x, y, width, height) {
      var x1 = x;
      var x2 = x + width;
      var y1 = y;
      var y2 = y + height;

      // ПРИМЕЧАНИЕ: gl.bufferData(gl.ARRAY_BUFFER, ...) будет воздействовать
      // на любой буфер, привязанный к точке привязки `ARRAY_BUFFER`,
      // но пока у нас есть только один буфер. Если бы у нас было больше одного,
      // то мы бы хотели сначала привязать этот буфер к массиву `ARRAY_BUFFER`.

      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
         x1, y1,
         x2, y1,
         x1, y2,
         x1, y2,
         x2, y1,
         x2, y2]), gl.STATIC_DRAW);
    }

А вот и прямоугольники.

{{{example url="../webgl-2d-rectangles.html" }}}

Надеюсь, вы теперь видите, что WebGL на самом деле довольно простой API. Ну, хорошо, "простой" должно быть не совсем подходящее слово. То, что он делает, — это просто. Он просто выполняет пару предоставляемых пользователем функций: вершинный и фрагментный шейдеры и рисует треугольники, линии или точки.

Хотя это может стать более сложным для выполнения в 3D, это усложнение
добавляете вы, программист, в виде более сложных шейдеров. Сам API WebGL — это просто растеризатор, и концептуально он довольно прост.

Мы рассмотрели небольшой пример, показывающий, как предоставить данные в виде атрибута и двух uniform переменных. Обычно используется несколько атрибутов и множество uniform-переменных. В начале статьи мы также упомянули *переменные*(varyings) и *текстуры*(textures). Они появятся в последующих уроках.

Прежде чем мы продолжим, я хочу отметить, что для *большинства* приложений обновление данных в буфере, как мы сделали это в `setRectangle`, не является обычной практикой. Я использовал этот пример, потому что мне показалось, что его легче всего объяснить, так как он показывает координаты пикселей
в качестве входных данных и демонстрирует выполнение небольшого количества математических операций в GLSL. Это *не* неправильно, есть много случаев, когда это правильное решение, но вам следует [продолжить чтение, чтобы узнать
более распространенный способ позиционирования, ориентации и масштабирования объектов в WebGL](webgl-2d-translation.html).

Если вы 100% новичок в WebGL и понятия не имеете, что такое GLSL, шейдеры или что делает GPU, тогда ознакомьтесь с [основами того, как на самом деле работает WebGL](webgl-how-it-works.html). Возможно, вы также захотите взглянуть на следующее — [интерактивная диаграмма состояний](/webgl/lessons/resources/webgl-state-diagram.html), как еще одного способа понять, как работает WebGL.

Вам также следует хотя бы вкратце ознакомиться с [кодом шаблона, используемым здесь](webgl-boilerplate.html), который применяется в большинстве примеров. Вам также следует хотя бы бегло прочитать [как рисовать несколько объектов](webgl-drawing-multiple-things.html), чтобы дать вам некоторое представление о том, как устроены более типичные приложения WebGL, потому что, к сожалению, почти все примеры рисуют только один объект и поэтому не отображают эту структуру.

В остальном отсюда вы можете пойти в двух направлениях. Если вы интересуетесь обработкой изображений я покажу вам [как сделать некоторые способы обработки 2D изображений](webgl-image-processing.html). Если вам интересно узнать о переносе,
вращении и масштабировании, то [начните здесь](webgl-2d-translation.html).
